import { type NextRequest, NextResponse } from "next/server";
import { ImageRequest, ImageResponse } from "@/types";

export async function POST(request: NextRequest) {
  try {
    const body: ImageRequest = await request.json();

    if (!body.prompt) {
      return NextResponse.json(
        { error: "Image prompt is required" },
        { status: 400 },
      );
    }

    console.log("Generating image with Gemini for prompt:", body.prompt);
    console.log("Page number:", body.pageNumber || "N/A");
    console.log("Has reference image:", !!body.referenceImage);

    // Enhanced prompt for children's book style with character consistency
    let enhancedPrompt = `Create a children's book illustration: ${body.prompt}. Style: colorful, friendly, safe for kids, cartoon-like, whimsical, high quality digital art`;

    // Add character sheet for consistency if provided
    if (body.characterSheet) {
      enhancedPrompt = `${body.characterSheet}. ${enhancedPrompt}`;
    }

    // Add style specification if provided
    if (body.style) {
      enhancedPrompt += `. Art style: ${body.style}`;
    }

    // Add consistency instruction if this is not the first image
    if (body.referenceImage && body.pageNumber && body.pageNumber > 1) {
      enhancedPrompt += ". IMPORTANT: Keep the character design, art style, and visual consistency exactly the same as in the reference image. Maintain the same character appearance, color palette, and artistic style.";
    }

    // Check if Google API key is available
    const apiKey = process.env.GOOGLE_GENERATIVE_AI_API_KEY;
    if (!apiKey) {
      console.error("Google API key not found");
      return NextResponse.json(
        { error: "Google Generative AI API key is required. Please add GOOGLE_GENERATIVE_AI_API_KEY to your environment variables." },
        { status: 500 }
      );
    }

    // Use Gemini for image generation
    const { GoogleGenAI, Modality } = await import("@google/genai");
    const ai = new GoogleGenAI({ apiKey });

    // Prepare content based on whether we have a reference image
    let contents;
    
    if (body.referenceImage && body.pageNumber && body.pageNumber > 1) {
      // Use image-to-image generation for consistency
      console.log("Using reference image for consistency");
      contents = [
        { text: enhancedPrompt },
        {
          inlineData: {
            mimeType: "image/png", // Assume PNG, but this should ideally be dynamic
            data: body.referenceImage.replace(/^data:image\/[^;]+;base64,/, ""), // Remove data URL prefix if present
          },
        },
      ];
    } else {
      // Use text-to-image for the first image
      console.log("Generating first image (text-to-image)");
      contents = enhancedPrompt;
    }

    const response = await ai.models.generateContent({
      model: "gemini-2.0-flash-preview-image-generation",
      contents: contents,
      config: {
        responseModalities: [Modality.TEXT, Modality.IMAGE],
      },
    });

    // Extract image data from response
    let imageUrl = null;
    if (
      response.candidates &&
      response.candidates[0] &&
      response.candidates[0].content &&
      Array.isArray(response.candidates[0].content.parts)
    ) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          // Convert base64 to data URL
          const imageData = part.inlineData.data;
          const mimeType = part.inlineData.mimeType || "image/png";
          imageUrl = `data:${mimeType};base64,${imageData}`;
          break;
        }
      }
    }

    if (!imageUrl) {
      throw new Error("No image generated by Gemini");
    }

    console.log("Gemini image generated successfully");

    return NextResponse.json({
      imageUrl,
      prompt: body.prompt,
      generated: true,
    });
  } catch (error) {
    console.error("Gemini image generation error:", error);

    return NextResponse.json(
      {
        error: "Image generation failed",
        details: error instanceof Error ? error.message : "Unknown error occurred",
      },
      { status: 500 }
    );
  }
}
